{"ast":null,"code":"\"use strict\";\n'use client';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isModalPresentation = isModalPresentation;\nexports.isTransparentModalPresentation = isTransparentModalPresentation;\nexports.useIsDesktop = useIsDesktop;\nexports.convertStackStateToNonModalState = convertStackStateToNonModalState;\nexports.findLastNonModalIndex = findLastNonModalIndex;\nconst react_1 = __importDefault(require(\"react\"));\nfunction isModalPresentation(options) {\n  const presentation = options?.presentation;\n  return presentation === 'modal' || presentation === 'formSheet' || presentation === 'fullScreenModal' || presentation === 'containedModal' || presentation === 'transparentModal' || presentation === 'containedTransparentModal';\n}\nfunction isTransparentModalPresentation(options) {\n  const presentation = options?.presentation;\n  return presentation === 'transparentModal' || presentation === 'containedTransparentModal';\n}\nfunction useIsDesktop(breakpoint = 768) {\n  const isWeb = true;\n  const [isDesktop, setIsDesktop] = react_1.default.useState(false);\n  react_1.default.useEffect(() => {\n    if (!isWeb || typeof window === 'undefined') return;\n    const mql = window.matchMedia(`(min-width: ${breakpoint}px)`);\n    const listener = e => setIsDesktop(e.matches);\n    setIsDesktop(mql.matches);\n    mql.addEventListener('change', listener);\n    return () => mql.removeEventListener('change', listener);\n  }, [breakpoint, isWeb]);\n  return isDesktop;\n}\nfunction convertStackStateToNonModalState(state, descriptors, isWeb) {\n  if (!isWeb) {\n    return {\n      routes: state.routes,\n      index: state.index\n    };\n  }\n  const routes = state.routes.filter(route => {\n    return !isModalPresentation(descriptors[route.key].options);\n  });\n  let index = routes.findIndex(r => r.key === state.routes[state.index]?.key);\n  if (index < 0) {\n    index = routes.length > 0 ? routes.length - 1 : 0;\n  }\n  return {\n    routes,\n    index\n  };\n}\nfunction findLastNonModalIndex(state, descriptors) {\n  for (let i = state.routes.length - 1; i >= 0; i--) {\n    if (!isModalPresentation(descriptors[state.routes[i].key].options)) {\n      return i;\n    }\n  }\n  return -1;\n}","map":{"version":3,"names":["exports","isModalPresentation","isTransparentModalPresentation","useIsDesktop","convertStackStateToNonModalState","findLastNonModalIndex","react_1","__importDefault","require","options","presentation","breakpoint","isWeb","isDesktop","setIsDesktop","default","useState","useEffect","window","mql","matchMedia","listener","e","matches","addEventListener","removeEventListener","state","descriptors","routes","index","filter","route","key","findIndex","r","length","i"],"sources":["C:\\Users\\Sasha\\Desktop\\hahaton\\hahaton-front\\node_modules\\expo-router\\src\\modal\\web\\utils.ts"],"sourcesContent":["'use client';\nimport { ParamListBase, StackNavigationState } from '@react-navigation/native';\nimport React from 'react';\n\nimport { ExtendedStackNavigationOptions } from '../../layouts/StackClient';\n\n/**\n * A minimal subset of `ExtendedStackNavigationOptions` needed for the helper\n * @internal\n */\nexport type PresentationOptions = Partial<Pick<ExtendedStackNavigationOptions, 'presentation'>>;\n\n/**\n * Helper to determine if a given screen should be treated as a modal-type presentation\n *\n * @param options - The navigation options.\n * @returns Whether the screen should be treated as a modal-type presentation.\n *\n * @internal\n */\nexport function isModalPresentation(options?: PresentationOptions | null) {\n  const presentation = options?.presentation;\n  return (\n    presentation === 'modal' ||\n    presentation === 'formSheet' ||\n    presentation === 'fullScreenModal' ||\n    presentation === 'containedModal' ||\n    presentation === 'transparentModal' ||\n    presentation === 'containedTransparentModal'\n  );\n}\n\n/**\n * Helper to determine if a given screen should be treated as a transparent modal-type presentation\n *\n * @param options - The navigation options.\n * @returns Whether the screen should be treated as a transparent modal-type presentation.\n *\n * @internal\n */\nexport function isTransparentModalPresentation(options?: PresentationOptions | null) {\n  const presentation = options?.presentation;\n  return presentation === 'transparentModal' || presentation === 'containedTransparentModal';\n}\n\n/**\n * SSR-safe viewport detection: initial render always returns `false` so that\n * server and client markup match. The actual media query evaluation happens\n * after mount.\n *\n * @internal\n */\nexport function useIsDesktop(breakpoint: number = 768) {\n  const isWeb = process.env.EXPO_OS === 'web';\n\n  // Ensure server-side and initial client render agree (mobile first).\n  const [isDesktop, setIsDesktop] = React.useState<boolean>(false);\n\n  React.useEffect(() => {\n    if (!isWeb || typeof window === 'undefined') return;\n\n    const mql = window.matchMedia(`(min-width: ${breakpoint}px)`);\n    const listener = (e: MediaQueryListEvent) => setIsDesktop(e.matches);\n\n    // Update immediately after mount\n    setIsDesktop(mql.matches);\n\n    mql.addEventListener('change', listener);\n    return () => mql.removeEventListener('change', listener);\n  }, [breakpoint, isWeb]);\n\n  return isDesktop;\n}\n\n/**\n * Returns a copy of the given Stack navigation state with any modal-type routes removed\n * (only when running on the web) and a recalculated `index` that still points at the\n * currently active non-modal route. If the active route *is* a modal that gets\n * filtered out, we fall back to the last remaining route – this matches the logic\n * used inside `ModalStackView` so that the underlying `NativeStackView` never tries\n * to render a modal screen that is simultaneously being shown in the overlay.\n *\n * This helper is exported primarily for unit-testing; it should be considered\n * internal to `ModalStack.web` and not a public API.\n *\n * @param state - The navigation state.\n * @param descriptors - The navigation descriptors.\n * @param isWeb - Whether the current platform is web.\n * @returns The navigation state with any modal-type routes removed.\n *\n * @internal\n */\nexport function convertStackStateToNonModalState(\n  state: StackNavigationState<ParamListBase>,\n  descriptors: Record<string, { options: ExtendedStackNavigationOptions }>,\n  isWeb: boolean\n) {\n  if (!isWeb) {\n    return { routes: state.routes, index: state.index };\n  }\n\n  // Remove every modal-type route from the stack on web.\n  const routes = state.routes.filter((route) => {\n    return !isModalPresentation(descriptors[route.key].options);\n  });\n\n  // Recalculate the active index so it still points at the same non-modal route, or –\n  // if that route was filtered out – at the last remaining route.\n  let index = routes.findIndex((r) => r.key === state.routes[state.index]?.key);\n  if (index < 0) {\n    index = routes.length > 0 ? routes.length - 1 : 0;\n  }\n\n  return { routes, index };\n}\n\n/**\n * Returns the index of the last route in the stack that is *not* a modal.\n *\n * @param state - The navigation state.\n * @param descriptors - The navigation descriptors.\n * @returns The index of the last non-modal route.\n *\n * @internal\n */\nexport function findLastNonModalIndex(\n  state: StackNavigationState<ParamListBase>,\n  descriptors: Record<string, { options: ExtendedStackNavigationOptions }>\n) {\n  // Iterate backwards through the stack to find the last non-modal route.\n  for (let i = state.routes.length - 1; i >= 0; i--) {\n    if (!isModalPresentation(descriptors[state.routes[i].key].options)) {\n      return i;\n    }\n  }\n  return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}